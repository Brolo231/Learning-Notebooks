[
  {
    "title": "Chapter 10 - Files and Exceptions",
    "path": "Notebooks/Python /Crash Course/Chapter 10 - Files and Exceptions.html",
    "content": ""
  },
  {
    "title": "Chapter 09 - Classes",
    "path": "Notebooks/Python /Crash Course/Chapter 09 - Classes.html",
    "content": "# Classes\n\n<hr>\n\n## Table of Contents \n\n- Pg 2: Object-oriented programming\n- Pg 3: `__init__()`\n- Pg 4: Attributes\n- Pg 5: Inheritance\n- Pg 6: Overriding Methods from Parent Class\n- Pg 7: Composition\n- Pg 8: Importing Classes\n- Pg 9: Terminology summary\n\n$$new_page$$\n\n## OOP (Object Oriented Programming)\n\nBefore OOP, programs were mostly:\n- long scripts\n- excessive functions\n- global variables\n- difficult to expand on\n\nOOP allows you to model your program as a collection of objects. When you write a class, you define the general behavior that a whole category of objects can have \n\nWithout classes:\n- no objects\n- no encapsulation\n- no inheritence\n- no polymoprhism\n\nAlthough we have not learnt the above yet, these form the 4 pillars of OOP \n\n### What is an object? \n\nAn object is a real instance that is created from a class \n\n### Creating a simple class\n\n```\nclass Dog:\n\n    # doc-string describing what the class does \n    \"\"\"A simple attempt to model a dog.\"\"\" \n\n     def __init__(self, name, age):\n        \"\"\"Initialize name and age attributes.\"\"\"\n        self.name = name\n        self.age = age\n\n     def sit(self):\n        \"\"\"Simulate a dog sitting in response to a command.\"\"\"\n        print(f\"{self.name} is now sitting.\")\n\n     def roll_over(self):\n        \"\"\"Simulate rolling over in response to a command.\"\"\"\n        print(f\"{self.name} rolled over!\")\n```\n\nBy convention, capitalized names refer to classes in python \n\n$$new_page$$\n\n### The __init__() method \n\nA function that is part of a class is called a method. The ```__init__()``` method is a special method that python runs automatically whenever we create a new instance based on the Dog class. \n\nTo understand the ```self``` paarmeter we can compre the difference between a class and a function. A function is also an object in python, however it is usually stateless by default which means when you reuse a function it has no memory of previous calls to it. However when we create an instance of a class the changes we make to that instance persist in memory and previous changes are remembered. Now ```self``` does the follwoing:  \n\n- self = \u201cthis specific object\u201d\n- It allows methods to access and modify that object\u2019s own data\n\nThe following example showcases this distinction between using self and not using self\n\n```\nclass Example:\n    def __init__(self):\n        self.persistent = 0      # stored in the object (uses self)\n        temporary = 0           # local variable (NO self) \u2014 useless here\n\n    def increment(self):\n        self.persistent += 1    # modifies object state\n        temporary = 0           # local variable created fresh each call\n        temporary += 1\n\n        print(\"self.persistent =\", self.persistent)\n        print(\"temporary =\", temporary)\n```\n\nNow if we ran the following :\n\n```\ne = Example()\n\ne.increment()\ne.increment()\ne.increment()\n```\n\nWe would get this out put: \n\n```\nself.persistent = 1\ntemporary = 1\n\nself.persistent = 2\ntemporary = 1\n\nself.persistent = 3\ntemporary = 1\n```\n\nAny variable prefixed with self is available to every method in the class, and we\u2019ll also be able to access these variables through any instance created from the class.\n\n$$new_page$$\n\n## Attributes\n\nThere are two types of attributes:\n- Instance attributes\n    - These belong to each object separately  \n- Class attributes\n    - These belong to the class itself, and are shared by all instances.\n\n\n```\nclass User:\n    total_users = 0   # class attribute\n\n    def __init__(self, name):\n        User.total_users += 1\n        self.name = name   # instance attribute\n```\n\n### Default attribute values \n\nWe can use default attribute values similarily to how we used default paramter values in functions \n\n```\nclass User:\n    def __init__(self, username, active = True, role = 'user'):\n        self.username = username\n        self.active = active\n        self.role = role\n\nu1 = User(\"john\")\nu2 = User(\"alice\", role=\"admin\")\n\nprint(u2.role)\n```\n\n$$new_page$$\n\n## Inheritance \n\nInheritance allows you to define new classes based on other versions of classes previously written. \n\nWhen one class inherits from another, it takes on the attributes and methods of the first class.\n\nThe original class is called the parent class (superclass), and the new class is the child class (subclass). The child class can inherit any or all of the attributes and methods of its parent class, but it\u2019s also free to define new attributes and methods of its own.\n\nThe following is a simple example of a class inheriting the methods and attributes from another class \n\n```\nclass Car:\n    \"\"\"A simple attempt to represent a car.\"\"\"\n\n    def __init__(self, make, model, year):\n        \"\"\"Initialize attributes to describe a car.\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    def get_descriptive_name(self):\n        \"\"\"Return a neatly formatted descriptive name.\"\"\"\n        long_name = f\"{self.year} {self.make} {self.model}\"\n        return long_name.title()\n\n    def read_odometer(self):\n        \"\"\"Print a statement showing the car's mileage.\"\"\"\n        print(f\"This car has {self.odometer_reading} miles on it.\")\n\n    def update_odometer(self, mileage):\n        \"\"\"Set the odometer reading to the given value.\"\"\"\n        if mileage >= self.odometer_reading:\n            self.odometer_reading = mileage\n        else:\n            print(\"You can't roll back an odometer!\")\n\n    def increment_odometer(self, miles):\n        \"\"\"Add the given amount to the odometer reading.\"\"\"\n        self.odometer_reading += miles\n\nclass ElectricCar(Car):\n    \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\"\n\n    def __init__(self, make, model, year):\n        \"\"\"Initialize attributes of the parent class.\"\"\"\n        super().__init__(make, model, year)\n\n\n\u277a my_leaf = ElectricCar('nissan', 'leaf', 2024)\nprint(my_leaf.get_descriptive_name())\n```\n\n**Note:** ```The super()``` function is a specialized function that allows you to call a method from the parent class. \n\nTo inherit the properties from another class we simply input the parent class's name in the parentheses of the new child class we are creating \n\n**Note:** When you inherit from another class, that child class automatically has access to all the parent class's methods and attributes \n\n$$new_page$$\n\n## Overriding methods from the parent class \n\nYou can override any method from the parent class that doesn\u2019t fit what you\u2019re trying to model with the child class. To do this, you define a method in the child class with the same name as the method you want to override in the parent class. Python will disregard the parent class method and only pay attention to the method you define in the child class.\n\n```\nclass ElectricCar(Car):\n    --snip--\n\n    def fill_gas_tank(self):\n        \"\"\"Electric cars don't have gas tanks.\"\"\"\n        print(\"This car doesn't have a gas tank!\")\n```\n\n$$new_page$$\n\n## Composition \n\nComposition is when:\n- One class owns another class as part of itself\n- The relationship is: \u201chas a\u201d, not \u201cis a\u201d\n\n```\nclass Car:\n     --snip--\n\nclass Battery:\n     \"\"\"A simple attempt to model a battery for an electric car.\"\"\"\n\n     def __init__(self, battery_size=40):\n        \"\"\"Initialize the battery's attributes.\"\"\"\n        self.battery_size = battery_size\n\n     def describe_battery(self):\n        \"\"\"Print a statement describing the battery size.\"\"\"\n        print(f\"This car has a {self.battery_size}-kWh battery.\")\n\n\nclass ElectricCar(Car):\n    \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\"\n\n    def __init__(self, make, model, year):\n        \"\"\"\n        Initialize attributes of the parent class.\n        Then initialize attributes specific to an electric car.\n        \"\"\"\n        super().__init__(make, model, year)\n        self.battery = Battery()\n\nmy_leaf = ElectricCar('nissan', 'leaf', 2024)\nprint(my_leaf.get_descriptive_name())\nmy_leaf.battery.describe_battery()\n```\n\n$$new_page$$\n\n## Importing classes \n\nPython allows you to store classes in modules and then import the classes you need into your main program \n\nIt is good practice to write a doc-string for each module you create \n\nTo import a class from a module we can call the python file name and then import the class using the Class Name\n\nFor example:\n\n```\nfrom car import Car\n```\n\n### Importing an Entire Module\n\nWe can also import an entire module and then access the classes you need using dot notation. \n\n```\nimport car\n```\n\n### Using aliases \n\nWhen importing from a module we can use an alias to shorten the keyword we need to enter in order to call the class \n\n```\nfrom electric_car import ElectricCar as EC\n```\n\n## Terminology \n\n| Term | Meaning |\n|------|--------|\n| Class | A blueprint that defines the structure and behavior of objects |\n| Object | A real instance created from a class |\n| Method | A function that belongs to a class |\n| Attribute | A variable that belongs to an object or a class |\n| Instance attribute | An attribute that belongs to a specific object (each object has its own copy) |\n| Class attribute | An attribute shared by all instances of a class |\n| Constructor | The `__init__()` method that initializes a new object |\n| self | Refers to the current object; used to access its attributes and methods |\n| Inheritance | \u201cis a\u201d relationship (e.g., Dog is an Animal) |\n| Parent / Base class | The class being inherited from |\n| Child / Subclass | The class that inherits from another class |\n| super() | Calls a method from the parent class, usually the constructor |\n| Overriding | Replacing a parent class method with a new version in the child class |\n| Composition | \u201chas a\u201d relationship (e.g., Car has an Engine) |\n| Component class | A class that is contained inside another class (used in composition) |\n| Encapsulation | Keeping data and behavior together and controlling access to them |\n| Polymorphism | Different objects responding differently to the same method name |\n| Module | A Python file that contains classes or functions |\n| Import | Bringing a class or module into another file so it can be used |\n| Alias | A short alternative name given during import (e.g., `as EC`) |"
  },
  {
    "title": "Python Patterns for Leetcode",
    "path": "Notebooks/Leetcode/Python Patterns for Leetcode.html",
    "content": "LeetCode Python \u2013 Practical Patterns & Advanced Constructs\n\nThis guide focuses on useful Python patterns that appear frequently in\nLeetCode problems. We skip trivial loops and instead show powerful\nidioms that improve clarity and performance.\n\n------------------------------------------------------------------------\n\n1. Enumerate (Index + Value Together)\n\n    nums = [10, 20, 30]\n    for i, val in enumerate(nums):\n        print(i, val)\n\nWhy useful: When you need both index and value (arrays, two-sum, DP\ntransitions).\n\n------------------------------------------------------------------------\n\n2. Zip (Parallel Iteration)\n\n    names = [\"a\", \"b\", \"c\"]\n    scores = [90, 80, 70]\n\n    for name, score in zip(names, scores):\n        print(name, score)\n\nUse case: Merging two arrays, comparing strings, interval problems.\n\n------------------------------------------------------------------------\n\n3. List Comprehensions (Filtered Transformations)\n\n    squares = [x * x for x in range(10) if x % 2 == 0]\n\nUse case: Clean transformations, fast filtering.\n\n------------------------------------------------------------------------\n\n4. Dictionary Comprehensions\n\n    freq = {x: nums.count(x) for x in set(nums)}\n\nBetter version:\n\n    from collections import Counter\n    freq = Counter(nums)\n\nUse case: Frequency counting, hash maps.\n\n------------------------------------------------------------------------\n\n5. Defaultdict (Avoid Key Errors)\n\n    from collections import defaultdict\n\n    graph = defaultdict(list)\n    graph[1].append(2)\n\nUse case: Graph adjacency lists, grouping problems.\n\n------------------------------------------------------------------------\n\n6. Deque (Fast Queue & Sliding Window)\n\n    from collections import deque\n\n    q = deque()\n    q.append(1)\n    q.appendleft(0)\n    q.popleft()\n\nUse case: BFS, sliding window, monotonic queue.\n\n------------------------------------------------------------------------\n\n7. Heap (Priority Queue)\n\n    import heapq\n\n    heap = []\n    heapq.heappush(heap, 5)\n    heapq.heappush(heap, 1)\n    smallest = heapq.heappop(heap)\n\nUse case: Top K elements, scheduling, Dijkstra.\n\n------------------------------------------------------------------------\n\n8. Bisect (Binary Search Insert Position)\n\n    import bisect\n\n    arr = [1, 3, 5, 7]\n    pos = bisect.bisect_left(arr, 4)\n\nUse case: LIS, insert sorted, binary search patterns.\n\n------------------------------------------------------------------------\n\n9. Two Pointers Pattern\n\n    l, r = 0, len(nums) - 1\n    while l < r:\n        if nums[l] + nums[r] < target:\n            l += 1\n        else:\n            r -= 1\n\nUse case: Sorted arrays, pair sums, partitioning.\n\n------------------------------------------------------------------------\n\n10. Sliding Window Template\n\n    l = 0\n    freq = {}\n\n    for r in range(len(s)):\n        freq[s[r]] = freq.get(s[r], 0) + 1\n\n        while invalid_window():\n            freq[s[l]] -= 1\n            l += 1\n\nUse case: Longest substring, subarray sums, constraints.\n\n------------------------------------------------------------------------\n\n11. Prefix Sums\n\n    prefix = [0]\n    for x in nums:\n        prefix.append(prefix[-1] + x)\n\n    sum_lr = prefix[r + 1] - prefix[l]\n\nUse case: Range sum queries, subarray problems.\n\n------------------------------------------------------------------------\n\n12. Sorted with Custom Key\n\n    pairs = [(1, 3), (2, 1), (4, 2)]\n    pairs.sort(key=lambda x: x[1])\n\nUse case: Intervals, greedy scheduling, sorting by second value.\n\n------------------------------------------------------------------------\n\n13. Sets & Fast Membership\n\n    seen = set()\n    if x in seen:\n        return True\n    seen.add(x)\n\nUse case: Cycle detection, duplicates, visited tracking.\n\n------------------------------------------------------------------------\n\n14. Recursion + Memoization (DP)\n\n    from functools import lru_cache\n\n    @lru_cache(None)\n    def dfs(i):\n        if i >= n:\n            return 0\n        return max(dfs(i+1), nums[i] + dfs(i+2))\n\nUse case: DP, tree recursion, exponential pruning.\n\n------------------------------------------------------------------------\n\n15. BFS Template\n\n    from collections import deque\n\n    q = deque([start])\n    visited = set([start])\n\n    while q:\n        node = q.popleft()\n        for nei in graph[node]:\n            if nei not in visited:\n                visited.add(nei)\n                q.append(nei)\n\nUse case: Shortest paths, grids, tree levels.\n\n------------------------------------------------------------------------\n\n16. DFS Template\n\n    def dfs(node):\n        visited.add(node)\n        for nei in graph[node]:\n            if nei not in visited:\n                dfs(nei)\n\nUse case: Connected components, tree traversal, backtracking.\n\n------------------------------------------------------------------------\n\n17. Union Find (Disjoint Set)\n\n    parent = list(range(n))\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(a, b):\n        pa, pb = find(a), find(b)\n        if pa != pb:\n            parent[pb] = pa\n\nUse case: Graph connectivity, cycles, Kruskal.\n\n------------------------------------------------------------------------\n\n18. Trie Skeleton\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.end = False\n\nUse case: Prefix search, word dictionary, autocomplete.\n\n------------------------------------------------------------------------\n\n19. Bit Manipulation (Common Tricks)\n\n    # Check if odd\n    x & 1\n\n    # Turn off lowest set bit\n    x & (x - 1)\n\nUse case: Subsets, masks, state compression.\n\n------------------------------------------------------------------------\n\n20. Generator Expressions (Memory Efficient)\n\n    total = sum(x * x for x in nums if x % 2 == 0)\n\nUse case: Large inputs, streaming computation.\n\n------------------------------------------------------------------------\n\nFinal Advice\n\n\u2022 Master patterns more than syntax\n\u2022 Learn when to use: two pointers, sliding window, BFS, DFS, DP\n\u2022 Practice reading constraints before coding\n\u2022 Optimize only after correctness\n\n------------------------------------------------------------------------\n"
  }
]